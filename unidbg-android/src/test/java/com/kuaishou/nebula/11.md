🔍 encryptEncData 函数深度分析（地址：0x40CD4）

根据反编译代码和 KSEmulator.java，我将详细分析 opcode 10400 的加密流程：

  ---
📋 一、函数签名与参数

__int64 __fastcall sub_40CD4(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
- a1: JNIEnv 指针
- a2: Context 对象（存储配置和状态）
- a3: opcode（10400/10405/10408等）
- a4: 参数对象（JNI对象）

  ---
⚠️ 二、关键检查点（执行前必须满足）

1. 反调试检查 (line 385-406)

if ((dword_70C10 & 0x80000000) == 0 && (dword_70C14 - 1) * dword_70C14 < 0)
goto LABEL_5;  // 失败则报错 70001
- dword_70C10: 调试标志位
- dword_70C14: 环境检查因子

2. 全局标志检查 (line 507-522) ⚠️ 核心检查

// KSEmulator.java:825-843 对应
if ((qword_70910 & 0x1800000000000LL) == 0) {
sub_3B350(a1, 70012, "70012");  // 错误：环境未初始化
}
含义：检查 qword_70910 的 bit 51 和 bit 52 是否被设置（由 setGlobalFlagsEarly() 设置）

3. 安全特性标志检查 (line 528-544)

// KSEmulator.java:836-843 对应
if ((byte_7091F & 0x20) == 0) {
sub_3B350(a1, 70117, &unk_59396);  // 错误：安全特性未启用
return 0;
}
含义：检查 byte_7091F 的 bit 5，控制是否启用安全加密模式

  ---
🔄 三、Opcode 10400 执行路径分析

⏺ 路径 1: Opcode 判断与分支 (line 436-493)

if (v348 == 10412) {
// 特殊处理 10412 (不同加密分支)
sub_3F16C(a1, v19, v353);
} else {
// ⭐ opcode 10400 走这个分支 (line 498)
sub_3E5C0(a1, v19);  // 核心验证函数
}

关键点：sub_3E5C0() 是 签名验证函数（参考 sub_3E5C0.txt）

  ---
路径 2: 参数读取 (line 593-733)

// 读取参数 0：输入数据（ByteArray）
v34 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1384LL))(a1, a4, 0);

// 读取参数 1：类型标识
v40 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1384LL))(a1, a4, 1);
v45 = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, v349, 0);

对应 KSEmulator.java:846-879：
// opcode 10400 期望的参数类型
// 参数[0]: byte[] 字节数组
// 参数[1]: String 类型标识（如 "app" 或其他）

  ---
路径 3: 加密数据准备 (line 2404-2444) ⚠️ 核心区域

// Line 2406-2418: 读取 ByteArray 数据到内存
v135 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1384LL))(a1, a4, 0);
v136 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, v135);  // 获取长度
v137 = (int)v136 + 1LL;  // 分配长度+1
v138 = calloc(v137, 1u);  // 分配内存
memset(v138, 0, v137);

// ⭐ Line 2413-2418: GetByteArrayRegion - 读取字节数据
(*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, void *))(*(_QWORD *)a1 + 1600LL))(
a1,      // JNIEnv
v135,    // ByteArray对象
0,       // 起始索引
v347,    // 长度
v138     // 目标缓冲区
);

// Line 2419-2428: 创建加密参数结构体
v139 = operator new(0x20u);  // 分配32字节结构体
*(_QWORD *)v139 = v138;      // +0x00: 数据指针
*(_DWORD *)(v139 + 8) = v347; // +0x08: 数据长度
// +0x0C: 密钥类型（稍后设置）
// +0x10: 密钥数据指针（稍后设置）
// +0x18: 密钥长度（稍后设置）

对应 KSEmulator.java:858-863：
byte[] requestBytes = hexToBytes(ENC_DATA_REQUEST_HEX);
// 实际调用中读取的数据长度应为 1801 字节（来自抓包）

  ---
路径 4: Opcode 特定处理 (line 977-1308)

Case 1: 检查 opcode 范围 (line 977)

if (v348 - 10400 <= 0x12 && ((1 << (v348 + 96)) & 0x62061) != 0 && v346 == 1)

位掩码解析：
- 0x62061 的二进制：0110 0010 0000 0110 0001
- 对应的 opcode：10400, 10405, 10406, 10408, 10410, 10414, 10417, 10418
- ⭐ opcode 10400 满足条件！

Case 2: 参数个数检查 (line 979)

if (v11 != 8) {  // 期望 8 个参数
// 错误：参数不足
}

KSEmulator.java 对应：
// 实际需要的参数结构
Object[] params = new Object[] {
env,              // 0: JNIEnv
thiz,             // 1: this对象
opcode,           // 2: 10400
byteArray,        // 3: 加密数据
typeString,       // 4: 类型标识
???,              // 5: 未知参数
???,              // 6: 未知参数
???               // 7: 未知参数
};

  ---
路径 5: 加密算法调用 (line 1524-1577)

// Line 1525-1543: 构建加密上下文
v179 = sub_40374();  // 获取加密上下文
v180 = v368;          // 参数列表
v181 = v179;
v182 = v367 + 24;     // 偏移

// 构建加密参数
sub_D6F8(v360);       // 初始化字符串
sub_45208(v375, v182, v180, v360);  // 组装参数

// ⭐ Line 1543: 核心加密函数
v186 = sub_A720(
&v378,      // 输出缓冲区
v181,       // 加密上下文
v10,        // 随机数种子
v348,       // opcode (10400)
v183,       // 输入数据1
v184,       // 输入数据2
v342,       // 密钥类型
0,          // 保留字段
v346,       // 加密模式
v185        // 其他参数
);

关键函数 sub_A720：
- 这是真正的加密实现
- 输入：原始数据、opcode、密钥类型
- 输出：加密后的字符串（存储在 v378）

  ---
路径 6: 输出处理 (line 1578-1696)

if (v348 == 10411) {
// 特殊处理 10411
} else if (v348 == 10405) {
// ⭐ 10405 的处理逻辑（可能与 10400 类似）
} else {
// Line 1604-1696: ⭐ opcode 10400 的输出处理
switch (v348) {
case 0x28AD:  // 10413
// 直接返回字符串
v202 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a1 + 1336LL))(a1, v201);
break;

          case 0x28B1:  // 10417
              // Base64 编码
              sub_3CC28(&tv, v206, v207);
              v15 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v208);
              break;

          case 0x28B2:  // 10418 ⚠️ 最复杂的加密格式
              // 构建加密头部（24字节）
              LODWORD(v375[0]) = 20801;  // 魔数
              WORD1(v375[0]) = v277;     // 加密模式标识
              DWORD1(v375[0]) = *(_DWORD *)(qword_70998 + 148);  // 设备标识
              HIDWORD(v375[0]) = sub_120D8(...);  // 数据哈希
              LODWORD(v375[1]) = (int)(tv.tv_usec / 1000 + 1000 * LODWORD(tv.tv_sec)) / 1000;  // 时间戳
              DWORD2(v375[0]) = v294;    // 递增序列号

              // 计算校验和
              v298 = 0;
              for (v297 = 0; v297 != 23; v297++)
                  v298 += *((unsigned __int8 *)v375 + v297);
              if (v298 > 0xFF)
                  v298 = -v298;

              // XOR 加密头部
              for (v301 = 0; v301 != 23; v301++)
                  *((_BYTE *)v375 + v301) ^= (unsigned __int8)v298 ^ (unsigned __int8)v301;

              // Line 1850-1948: 调用加密算法
              v317 = (void *)sub_11BF0(v335, v305, v316, n, &tv);

              break;
      }
}

  ---

⏺ 🧪 四、关键加密流程详细注释

1. 加密数据结构体（32字节）

struct EncryptParams {
void* data;          // +0x00: 输入数据指针
uint32_t dataLen;    // +0x08: 数据长度
uint32_t keyType;    // +0x0C: 密钥类型（0=无密钥，1=使用p10密钥等）
void* keyData;       // +0x10: 密钥数据指针
uint32_t keyLen;     // +0x18: 密钥长度
uint32_t reserved;   // +0x1C: 保留字段
};

2. 加密头部结构（24字节，仅 opcode 10418）

struct EncryptHeader {
uint16_t magic;      // +0x00: 0x5141 (20801)
uint16_t mode;       // +0x02: 加密模式（0=普通，1=高级，2=签名）
uint32_t deviceId;   // +0x04: 设备标识
uint32_t dataHash;   // +0x08: 数据哈希值
uint32_t timestamp;  // +0x0C: 时间戳（秒）
uint32_t sequence;   // +0x10: 递增序列号
uint32_t flags;      // +0x14: 标志位（从 qword_70910 提取）
uint8_t checksum;    // +0x17: 校验和
};

标志位构成：
flags = (qword_70910 >> 61 & 1)      // bit 0: 特性1
| (qword_70910 >> 57 & 2)      // bit 1: 特性2
| (qword_70910 >> 60 & 4)      // bit 2: 特性3
| (qword_70910 >> 53 & 0x10)   // bit 4: 特性4
| (qword_70910 >> 54 & 0x20)   // bit 5: 特性5
| (qword_70910 >> 44 & 0x40)   // bit 6: 特性6
| 0xD00;                        // 固定标志

  ---
🎯 五、opcode 10400 的完整执行流程

graph TB
A[开始] --> B{反调试检查}
B -->|失败| Z1[返回错误 70001]
B -->|通过| C{qword_70910检查}
C -->|失败| Z2[返回错误 70012]
C -->|通过| D{byte_7091F检查}
D -->|失败| Z3[返回错误 70117]
D -->|通过| E[读取参数0: ByteArray]
E --> F[读取参数1: String类型]
F --> G{验证签名 sub_3E5C0}
G -->|失败| Z4[返回错误 70014]
G -->|通过| H[分配加密结构体32字节]
H --> I[GetByteArrayRegion读取数据]
I --> J{检查opcode范围}
J -->|不匹配| K[基础加密流程]
J -->|匹配10400| L[高级加密流程]
L --> M[构建加密上下文 sub_40374]
M --> N[调用加密函数 sub_A720]
N --> O[生成加密字符串]
O --> P[NewStringUTF返回结果]
P --> Q[释放内存]
Q --> R[结束]

  ---
📊 六、关键函数调用关系

sub_40CD4 (encryptEncData)
├── sub_3E5C0 (签名验证)
├── sub_40374 (获取加密上下文)
├── sub_A720 (核心加密函数) ⚠️ 最核心
│   ├── 输入: 原始数据、opcode、密钥
│   └── 输出: 加密字符串
├── sub_11BF0 (高级加密算法，仅10418等)
│   ├── 输入: 带头部的数据
│   └── 输出: 48/64字节密文
└── sub_3CC28 (Base64编码，可选)

  ---

⏺ 🔐 七、Opcode 10400 的特殊性分析

根据代码分析，opcode 10400 的特点：

1. 参数期望

// KSEmulator.java:846-879 的关键发现
// ⚠️ 错误原因：参数类型不匹配！

// ❌ 错误用法（导致类型转换失败）：
params[0] = vm.addLocalObject(new ByteArray(vm, requestBytes));
// DalvikVM64:3176: GetObjectClass error: class not found

// ✅ 正确用法（推测）：
params[0] = requestBytes;  // 直接传递 byte[]
// 或者
params[0] = vm.addLocalObject(StringObject.create(vm, ENC_DATA_REQUEST_HEX));  // Hex字符串

2. 预期的参数列表

根据 line 979 的检查（v11 != 8），完整参数应为：
Object[] params = new Object[8];
params[0] = ???;           // 加密数据（类型待确认：byte[]? Hex字符串?）
params[1] = "app";         // 类型标识
params[2] = ???;           // 未知参数2
params[3] = ???;           // 未知参数3
params[4] = ???;           // 未知参数4
params[5] = ???;           // 未知参数5
params[6] = ???;           // 未知参数6
params[7] = ???;           // 未知参数7

3. 输出格式推测

根据 line 1543 的 sub_A720 调用：
- 如果 opcode 在 10400-10418 范围且满足条件
- 可能返回 Base64 编码的加密字符串
- 或者返回 Hex 编码的密文

  ---
⚡ 八、调试建议

问题诊断：

当前 KSEmulator.java:845 使用 opcode 10400 失败的原因：

1. 参数类型错误（最可能）：
   - 代码期望的是 Hex字符串数组 而非 ByteArray
   - 参考 line 1043 的处理：(char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, v98, 0)
   - 这是 GetStringUTFChars() 函数，说明参数应该是 String 类型
2. 参数数量不足：
   - 需要 8 个参数，当前只有 3 个
3. 环境检查失败：
   - qword_70910 或 byte_7091F 未正确设置

修复方案：

// 方案 1: 使用 Hex 字符串
DvmObject<?> hexString = new StringObject(vm, ENC_DATA_REQUEST_HEX);
params[0] = vm.addLocalObject(hexString);
params[1] = vm.addLocalObject(new StringObject(vm, "app"));
// ... 添加其他参数

// 方案 2: 切换到 opcode 10408（可能更简单）
int opcode = 10408;  // 该 opcode 可能只需要更少的参数

  ---

⏺ 📝 总结：encryptEncData (0x40CD4) 完整流程

✅ 关键发现

1. Opcode 10400 执行条件：
   - ✅ 通过反调试检查（dword_70C10/dword_70C14）
   - ✅ qword_70910 的 bit 51-52 必须设置（由 setGlobalFlagsEarly 完成）
   - ✅ byte_7091F 的 bit 5 必须设置（安全模式启用）
   - ✅ 签名验证通过（sub_3E5C0）
   - ⚠️ 需要 8 个参数（当前只有 3 个）
2. 参数类型问题：
   - ❌ 错误：ByteArray 对象（导致 GetObjectClass 失败）
   - ✅ 正确：应该是 String（Hex 字符串）或直接的 byte[]
3. 加密流程：
   输入数据 → 签名验证 → 构建加密结构体 → sub_A720加密 → 返回加密字符串
4. 输出格式：
   - 可能是 Base64 编码（某些 opcode）
   - 或者 Hex 编码
   - 或者 带24字节头部的密文（opcode 10418）
